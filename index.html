<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Markov Text Generator</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: Georgia, serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      background: #f5f5f0;
      color: #333;
    }
    h1 {
      font-size: 1.8rem;
      margin-bottom: 0.5rem;
    }
    .subtitle {
      color: #666;
      margin-bottom: 2rem;
      font-style: italic;
    }
    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: bold;
    }
    textarea {
      width: 100%;
      padding: 0.75rem;
      font-family: monospace;
      font-size: 0.9rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
    }
    .controls {
      display: flex;
      gap: 1rem;
      margin: 1rem 0;
      flex-wrap: wrap;
      align-items: center;
    }
    button {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background: #2563eb;
      color: white;
    }
    button:hover {
      background: #1d4ed8;
    }
    button:disabled {
      background: #9ca3af;
      cursor: not-allowed;
    }
    button.secondary {
      background: #6b7280;
    }
    button.secondary:hover {
      background: #4b5563;
    }
    input[type="number"] {
      width: 80px;
      padding: 0.5rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    input[type="text"] {
      width: 150px;
      padding: 0.5rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .output {
      background: white;
      padding: 1.5rem;
      border-radius: 4px;
      border: 1px solid #ddd;
      min-height: 150px;
      line-height: 1.8;
      font-size: 1.1rem;
    }
    .status {
      padding: 0.75rem;
      border-radius: 4px;
      margin: 1rem 0;
    }
    .status.loading {
      background: #fef3c7;
      color: #92400e;
    }
    .status.error {
      background: #fee2e2;
      color: #991b1b;
    }
    .status.success {
      background: #d1fae5;
      color: #065f46;
    }
    .stats {
      font-size: 0.85rem;
      color: #666;
      margin-top: 1rem;
    }
    .vocab-preview {
      font-family: monospace;
      font-size: 0.8rem;
      color: #666;
      margin-top: 0.5rem;
      max-height: 60px;
      overflow-y: auto;
    }
    footer {
      margin-top: 3rem;
      padding-top: 1rem;
      border-top: 1px solid #ddd;
      font-size: 0.85rem;
      color: #666;
    }
    footer a {
      color: #2563eb;
    }
  </style>
</head>
<body>
  <h1>Markov Text Generator</h1>
  <p class="subtitle">Feed it URLs, get procedurally generated nonsense back</p>

  <label for="urls">URLs (one per line):</label>
  <textarea id="urls" rows="4" placeholder="https://example.com/article1
https://example.com/article2"></textarea>

  <div class="controls">
    <button id="loadBtn" onclick="loadUrls()">Load URLs</button>
    <button id="clearBtn" class="secondary" onclick="clearAll()">Clear</button>
  </div>

  <div id="status" class="status" style="display: none;"></div>

  <div id="generatorSection" style="display: none;">
    <hr style="margin: 2rem 0;">

    <div class="controls">
      <label style="display: inline; margin: 0;">
        Words: <input type="number" id="numWords" value="50" min="1" max="500">
      </label>
      <label style="display: inline; margin: 0;">
        Start with: <input type="text" id="startWord" placeholder="(random)">
      </label>
      <button id="generateBtn" onclick="generate()">Generate</button>
      <button id="regenBtn" class="secondary" onclick="generate()">Regenerate</button>
    </div>

    <div id="output" class="output"></div>

    <div id="stats" class="stats"></div>
    <div id="vocabPreview" class="vocab-preview"></div>
  </div>

  <footer>
    <p>
      Built for <a href="https://scienceandsociety.columbia.edu/news/mapping-ai-hype">Mapping AI Hype</a>
      | <a href="https://github.com/chrishwiggins/markov-web">View Source</a>
    </p>
    <p>
      A 1st-order Markov chain links each word to its possible successors.
      Only words with 2+ distinct followers are kept, ensuring variety.
    </p>
  </footer>

  <script>
    let markovModel = null;
    let allWords = [];
    let vocab = new Set();

    async function loadUrls() {
      const urlsText = document.getElementById('urls').value.trim();
      if (!urlsText) {
        showStatus('Please enter at least one URL', 'error');
        return;
      }

      const urls = urlsText.split('\n').map(u => u.trim()).filter(u => u);
      if (urls.length === 0) {
        showStatus('Please enter at least one URL', 'error');
        return;
      }

      showStatus(`Loading ${urls.length} URL(s)...`, 'loading');
      document.getElementById('loadBtn').disabled = true;

      let combinedText = '';
      let successCount = 0;

      for (const url of urls) {
        try {
          const response = await fetch(`/api/fetch?url=${encodeURIComponent(url)}`);
          const data = await response.json();

          if (data.error) {
            console.error(`Error fetching ${url}: ${data.error}`);
          } else {
            combinedText += ' ' + data.text;
            successCount++;
          }
        } catch (error) {
          console.error(`Error fetching ${url}: ${error.message}`);
        }
      }

      document.getElementById('loadBtn').disabled = false;

      if (successCount === 0) {
        showStatus('Failed to load any URLs. Check the console for details.', 'error');
        return;
      }

      // Build Markov model
      buildModel(combinedText);

      showStatus(`Loaded ${successCount}/${urls.length} URLs. ${vocab.size} words in vocabulary.`, 'success');
      document.getElementById('generatorSection').style.display = 'block';

      // Show vocab preview
      const vocabArray = Array.from(vocab).sort();
      document.getElementById('vocabPreview').textContent =
        'Vocabulary: ' + vocabArray.join(', ');
    }

    function buildModel(text) {
      // Normalize and tokenize
      const words = text.toLowerCase()
        .split(/\s+/)
        .map(w => w.replace(/^[^a-z0-9]+|[^a-z0-9]+$/gi, ''))
        .filter(w => w.length > 0);

      allWords = words;

      // Build transitions
      const transitions = {};
      for (let i = 0; i < words.length - 1; i++) {
        const current = words[i];
        const next = words[i + 1];
        if (!transitions[current]) {
          transitions[current] = [];
        }
        transitions[current].push(next);
      }

      // Filter to degree >= 2
      markovModel = {};
      for (const [word, followers] of Object.entries(transitions)) {
        const uniqueFollowers = new Set(followers);
        if (uniqueFollowers.size >= 2) {
          markovModel[word] = followers;
        }
      }

      vocab = new Set(Object.keys(markovModel));
    }

    function generate() {
      if (!markovModel || vocab.size === 0) {
        showStatus('Load URLs first', 'error');
        return;
      }

      const numWords = parseInt(document.getElementById('numWords').value) || 50;
      const startWordInput = document.getElementById('startWord').value.trim().toLowerCase();

      let current;
      if (startWordInput) {
        if (!vocab.has(startWordInput)) {
          showStatus(`"${startWordInput}" not in vocabulary. Try one of: ${Array.from(vocab).slice(0, 10).join(', ')}...`, 'error');
          return;
        }
        current = startWordInput;
      } else {
        // Pick from empirical distribution of words in vocab
        const candidates = allWords.filter(w => vocab.has(w));
        current = candidates[Math.floor(Math.random() * candidates.length)];
      }

      const result = [current];

      for (let i = 0; i < numWords - 1; i++) {
        if (markovModel[current]) {
          const followers = markovModel[current];
          current = followers[Math.floor(Math.random() * followers.length)];
          result.push(current);
        } else {
          // Dead end - pick new start
          const candidates = allWords.filter(w => vocab.has(w));
          if (candidates.length === 0) break;
          current = candidates[Math.floor(Math.random() * candidates.length)];
          result.push(current);
        }
      }

      document.getElementById('output').textContent = result.join(' ');
      document.getElementById('stats').textContent =
        `Generated ${result.length} words starting with "${result[0]}"`;
    }

    function clearAll() {
      document.getElementById('urls').value = '';
      document.getElementById('output').textContent = '';
      document.getElementById('stats').textContent = '';
      document.getElementById('vocabPreview').textContent = '';
      document.getElementById('status').style.display = 'none';
      document.getElementById('generatorSection').style.display = 'none';
      markovModel = null;
      allWords = [];
      vocab = new Set();
    }

    function showStatus(message, type) {
      const el = document.getElementById('status');
      el.textContent = message;
      el.className = 'status ' + type;
      el.style.display = 'block';
    }
  </script>
</body>
</html>
